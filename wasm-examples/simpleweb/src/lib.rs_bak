use bevy::prelude::*;
use bevy::winit::WinitSettings;
use bevy_prototype_lyon::prelude::*;
use pdbtbx::{self, StrictnessLevel};
use protein_renderer::{Structure, StructurePlugin};
use std::io::BufReader;
use std::io::Cursor;
use wasm_bindgen::prelude::*;
use wasm_bindgen_futures::{spawn_local, JsFuture};
use web_sys::console;
use web_sys::HtmlInputElement;

// Event to trigger protein loading
#[derive(Event)]
pub struct LoadProteinEvent(pub Vec<u8>);

#[wasm_bindgen]
pub fn upload_protein_file(file_data: &[u8]) {
    // Get the Bevy app instance and send the event
    app.send_event(LoadProteinEvent(file_data.to_vec()));
}

fn handle_protein_upload(
    mut commands: Commands,
    mut meshes: ResMut<Assets<Mesh>>,
    mut materials: ResMut<Assets<StandardMaterial>>,
    mut upload_events: EventReader<LoadProteinEvent>,
) {
    for event in upload_events.read() {
        let LoadProteinEvent(file_data) = event;
        println!("Received protein data, length: {}", file_data.len());
        let cursor = Cursor::new(file_data);
        let buf_reader = BufReader::new(cursor);
        let (pdb, error) = pdbtbx::open_raw(buf_reader, StrictnessLevel::Medium).unwrap();
        // if let Some(error) = error {
        //     println!("Warning: PDB parsing had errors: {:?}", error);
        // }
        let structure = Structure::builder().pdb(pdb).build();
        let pbr = structure.to_pbr(&mut meshes, &mut materials);
        commands.spawn((structure, pbr));
    }
}

// Todo:
//    EscherMap --> PDBMap
//    MapState --> PDBState
//

#[cfg(target_arch = "wasm32")]
/// WASM Part.
#[derive(Resource)]
pub struct ReceiverResource<T> {
    pub rx: async_std::channel::Receiver<T>,
}

#[cfg(target_arch = "wasm32")]
fn listen_js_data(
    receiver: Res<ReceiverResource<Data>>,
    mut data_asset: ResMut<Assets<Data>>,
    mut data_resource: ResMut<ReactionState>,
) {
    if let Ok(escher_map) = receiver.rx.try_recv() {
        data_resource.reaction_data = Some(data_asset.add(escher_map));
        data_resource.loaded = false;
    }
}

#[cfg(target_arch = "wasm32")]
fn listen_js_info(receiver: Res<ReceiverResource<&'static str>>, mut info_box: ResMut<Info>) {}

#[cfg(target_arch = "wasm32")]
/// Main function with WASM additions.
/// Three main differences:
/// - Get WASM modules.
/// - Create a button that sends data through a channel.
/// - Insert a Receiver resource so that systems can listen to that.
fn main() {
    use async_std::channel::{unbounded, Receiver, Sender};
    let (map_sender, map_receiver): (Sender<EscherMap>, Receiver<EscherMap>) = unbounded();
    let (data_sender, data_receiver): (Sender<data::Data>, Receiver<data::Data>) = unbounded();

    // I/O feedback
    // there are two senders, one for the map and one for the data
    let (info_sender, info_receiver): (Sender<&'static str>, Receiver<&'static str>) = unbounded();
    let info_log1 = info_sender.clone();

    // When building for WASM, print panics to the browser console
    console_error_panic_hook::set_once();
    let document = web_sys::window().unwrap().document().unwrap();
    // button for loading maps
    let target_map = document
        .create_element("input")
        .unwrap_throw()
        .dyn_into::<HtmlInputElement>()
        .unwrap();
    target_map.set_type("file");
    target_map.set_name("fileb");
    target_map.set_id("fileb");
    target_map.set_class_name("fileb");
    // button for loading data
    let target_data = document
        .create_element("input")
        .unwrap_throw()
        .dyn_into::<HtmlInputElement>()
        .unwrap();
    target_data.set_type("file");
    target_data.set_name("fileData");
    target_data.set_id("fileData");
    target_data.set_class_name("fileData");

    let body = document.body().unwrap();
    body.append_child(&target_map).unwrap();
    body.append_child(&target_data).unwrap();

    let map_closure = Closure::wrap(Box::new(move |event: web_sys::Event| {
        let s = map_sender.clone();
        let info_log = info_log1.clone();
        spawn_local(async move {
            console::log_1(&"checking closure".into());
            if let Some(Some(file_list)) = event.target().map(|t| {
                t.dyn_ref::<HtmlInputElement>()
                    .expect("target_brows is an <input>")
                    .files()
            }) {
                let text = JsFuture::from(file_list.get(0).unwrap().text())
                    .await
                    .unwrap()
                    .as_string()
                    .unwrap();
                if let Ok(escher_map) = serde_json::from_str(&text) {
                    s.send(escher_map).await.unwrap();
                } else {
                    console::warn_1(&"Provided map does not have right shape".into());
                    info_log
                        .send("Failed loading map! Check that you JSON is correct.")
                        .await
                        .unwrap();
                }
            }
        })
    }) as Box<dyn FnMut(_)>);
    let data_closure = Closure::wrap(Box::new(move |event: web_sys::Event| {
        let s = data_sender.clone();
        let info_log = info_sender.clone();
        spawn_local(async move {
            console::log_1(&"checking closure".into());
            if let Some(Some(file_list)) = event.target().map(|t| {
                t.dyn_ref::<HtmlInputElement>()
                    .expect("target_brows is an <input>")
                    .files()
            }) {
                let text = JsFuture::from(file_list.get(0).unwrap().text())
                    .await
                    .unwrap()
                    .as_string()
                    .unwrap();
                if let Ok(data) = serde_json::from_str(&text) {
                    s.send(data).await.unwrap();
                } else {
                    console::warn_1(&"Provided file does not have right shape".into());
                    info_log
                        .send("Failed loading data! Check that you metabolism.json is correct.")
                        .await
                        .unwrap();
                }
            }
        })
    }) as Box<dyn FnMut(_)>);
    console::log_1(&"closure setup done!".into());
    target_map.set_onchange(Some(map_closure.as_ref().unchecked_ref()));
    target_data.set_onchange(Some(data_closure.as_ref().unchecked_ref()));

    App::new()
        .insert_resource(Msaa::Sample4)
        .insert_resource(WinitSettings::desktop_app())
        .insert_resource(ReceiverResource { rx: map_receiver })
        .insert_resource(ReceiverResource { rx: data_receiver })
        .insert_resource(ReceiverResource { rx: info_receiver })
        .add_plugins(DefaultPlugins.set(WindowPlugin {
            primary_window: Some(Window {
                title: "shu".to_string(),
                fit_canvas_to_parent: true,
                canvas: Some("#bevy".to_string()),
                ..default()
            }),
            ..default()
        }))
        // plugins from dependencies
        .add_plugins((PanCamPlugin, ShapePlugin))
        // internal plugins
        .add_plugins(screenshot::ScreenShotPlugin)
        .add_plugins(info::InfoPlugin)
        .add_plugins(EscherPlugin)
        .add_plugins(gui::GuiPlugin)
        .add_plugins(data::DataPlugin)
        .add_systems(Startup, setup_system)
        .add_plugins(aesthetics::AesPlugin)
        .add_plugins(legend::LegendPlugin)
        .run();
}

fn setup_system(mut commands: Commands, asset_server: Res<AssetServer>) {
    // let escher_handle: Handle<EscherMap> = asset_server.load("ecoli_core_map.json");
    commands.insert_resource(MapState {
        escher_map: escher_handle,
        loaded: false,
    });
    commands.insert_resource(data::ReactionState {
        reaction_data: None,
        loaded: false,
    });

    commands.spawn(Camera3dBundle {
        transform: Transform::from_xyz(0.0, 0.0, 10.0).looking_at(Vec3::ZERO, Vec3::Y),
        ..default()
    });

    // Add a light
    commands.spawn(PointLightBundle {
        point_light: PointLight {
            intensity: 1500.0,
            shadows_enabled: true,
            ..default()
        },
        transform: Transform::from_xyz(4.0, 8.0, 4.0),
        ..default()
    });
}

// #[wasm_bindgen]
// pub fn run() {
//     let mut app = App::new();
//     app.add_plugins(DefaultPlugins)
//         .add_plugins(StructurePlugin::new())
//         .add_event::<LoadProteinEvent>()
//         .add_systems(Update, handle_protein_upload)
//         .add_systems(Startup, setup_scene)
//         .run();
// }
